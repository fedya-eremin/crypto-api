// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package db_gen

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const addCurrencyPriceLog = `-- name: AddCurrencyPriceLog :exec
insert into coin_price_log (uuid, price_usd, coin_uuid, collected_at)
values
($1, $2, (select uuid from coin where symbol = $3), $4)
`

type AddCurrencyPriceLogParams struct {
	Uuid        uuid.UUID
	PriceUsd    string
	Symbol      string
	CollectedAt time.Time
}

func (q *Queries) AddCurrencyPriceLog(ctx context.Context, arg AddCurrencyPriceLogParams) error {
	_, err := q.db.Exec(ctx, addCurrencyPriceLog,
		arg.Uuid,
		arg.PriceUsd,
		arg.Symbol,
		arg.CollectedAt,
	)
	return err
}

const addCurrencyToWatchlist = `-- name: AddCurrencyToWatchlist :exec
insert into coin (uuid, symbol, watching, interval)
values
($1, $2, true, $3)
on conflict (symbol) do update
set watching = true,
	interval = $3
`

type AddCurrencyToWatchlistParams struct {
	Uuid     uuid.UUID
	Symbol   string
	Interval int32
}

func (q *Queries) AddCurrencyToWatchlist(ctx context.Context, arg AddCurrencyToWatchlistParams) error {
	_, err := q.db.Exec(ctx, addCurrencyToWatchlist, arg.Uuid, arg.Symbol, arg.Interval)
	return err
}

const bootstrapWatchingEntries = `-- name: BootstrapWatchingEntries :many
select c.uuid, c.symbol, c.interval from coin c
where c.watching is true
`

type BootstrapWatchingEntriesRow struct {
	Uuid     uuid.UUID
	Symbol   string
	Interval int32
}

func (q *Queries) BootstrapWatchingEntries(ctx context.Context) ([]BootstrapWatchingEntriesRow, error) {
	rows, err := q.db.Query(ctx, bootstrapWatchingEntries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BootstrapWatchingEntriesRow
	for rows.Next() {
		var i BootstrapWatchingEntriesRow
		if err := rows.Scan(&i.Uuid, &i.Symbol, &i.Interval); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNearestPrice = `-- name: GetNearestPrice :one
select cpl.uuid, cpl.price_usd, cpl.collected_at
from coin_price_log cpl
join coin c on cpl.coin_uuid = c.uuid
where c.symbol = $1 --and cpl.collected_at <= to_timestamp(sqlc.arg(timestamp)::bigint)
order by abs(extract(epoch from (cpl.collected_at - to_timestamp($2::bigint))))
limit 1
`

type GetNearestPriceParams struct {
	Symbol    string
	Timestamp int64
}

type GetNearestPriceRow struct {
	Uuid        uuid.UUID
	PriceUsd    string
	CollectedAt time.Time
}

func (q *Queries) GetNearestPrice(ctx context.Context, arg GetNearestPriceParams) (GetNearestPriceRow, error) {
	row := q.db.QueryRow(ctx, getNearestPrice, arg.Symbol, arg.Timestamp)
	var i GetNearestPriceRow
	err := row.Scan(&i.Uuid, &i.PriceUsd, &i.CollectedAt)
	return i, err
}

const unwatchCurrency = `-- name: UnwatchCurrency :exec
update coin
set watching = false
where symbol = $1
`

func (q *Queries) UnwatchCurrency(ctx context.Context, symbol string) error {
	_, err := q.db.Exec(ctx, unwatchCurrency, symbol)
	return err
}
